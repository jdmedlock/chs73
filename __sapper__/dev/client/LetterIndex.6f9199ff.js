import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, o as svg_element, c as claim_element, a as children, f as detach_dev, h as attr_dev, j as add_location, q as set_style, O as toggle_class, k as insert_dev, l as append_dev, u as listen_dev, x as noop, M as validate_each_argument, t as text, b as claim_text, m as set_data_dev, N as destroy_each } from './client.ac66945a.js';

// Create an index that associates letters of the alphabet with 
// the first person in the list whose last name starts with that letter
function createNameIndex(persons) {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const letterIndex = [];

  for(let i = 0; i < alphabet.length; i++) {
    const letter = alphabet.charAt(i);
    const firstMatch = persons.find(person => {
      return person.lastName.charAt(0) == letter ? true : false
    });
    if (firstMatch !== undefined) {
      letterIndex.push({ 
        letter: letter, 
        name: `#${ firstMatch.name.toLowerCase().replace(/\s+/g, '') }`
      });
    } else {
      if (letter !== 'A') {
        letterIndex.push({ 
          letter: letter, 
          name: letterIndex[i-1].name 
        });
      }
    }
  }

  return letterIndex
}

/* src/components/BackToTop.svelte generated by Svelte v3.35.0 */

const file$1 = "src/components/BackToTop.svelte";

function create_fragment$1(ctx) {
	let a;
	let svg;
	let defs;
	let clipPath;
	let rect0;
	let g2;
	let g1;
	let ellipse;
	let g0;
	let polygon;
	let rect1;
	let a_href_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			a = element("a");
			svg = svg_element("svg");
			defs = svg_element("defs");
			clipPath = svg_element("clipPath");
			rect0 = svg_element("rect");
			g2 = svg_element("g");
			g1 = svg_element("g");
			ellipse = svg_element("ellipse");
			g0 = svg_element("g");
			polygon = svg_element("polygon");
			rect1 = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, class: true });
			var a_nodes = children(a);

			svg = claim_element(
				a_nodes,
				"svg",
				{
					xmlns: true,
					"xmlns:xlink": true,
					style: true,
					viewBox: true,
					width: true,
					height: true
				},
				1
			);

			var svg_nodes = children(svg);
			defs = claim_element(svg_nodes, "defs", {}, 1);
			var defs_nodes = children(defs);
			clipPath = claim_element(defs_nodes, "clipPath", { id: true }, 1);
			var clipPath_nodes = children(clipPath);
			rect0 = claim_element(clipPath_nodes, "rect", { width: true, height: true }, 1);
			children(rect0).forEach(detach_dev);
			clipPath_nodes.forEach(detach_dev);
			defs_nodes.forEach(detach_dev);
			g2 = claim_element(svg_nodes, "g", { "clip-path": true }, 1);
			var g2_nodes = children(g2);
			g1 = claim_element(g2_nodes, "g", {}, 1);
			var g1_nodes = children(g1);

			ellipse = claim_element(
				g1_nodes,
				"ellipse",
				{
					"vector-effect": true,
					cx: true,
					cy: true,
					rx: true,
					ry: true,
					fill: true
				},
				1
			);

			children(ellipse).forEach(detach_dev);
			g0 = claim_element(g1_nodes, "g", {}, 1);
			var g0_nodes = children(g0);
			polygon = claim_element(g0_nodes, "polygon", { points: true, fill: true }, 1);
			children(polygon).forEach(detach_dev);

			rect1 = claim_element(
				g0_nodes,
				"rect",
				{
					x: true,
					y: true,
					width: true,
					height: true,
					transform: true,
					fill: true
				},
				1
			);

			children(rect1).forEach(detach_dev);
			g0_nodes.forEach(detach_dev);
			g1_nodes.forEach(detach_dev);
			g2_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect0, "width", "32");
			attr_dev(rect0, "height", "32");
			add_location(rect0, file$1, 49, 8, 1273);
			attr_dev(clipPath, "id", "_clipPath_pOOP9k0SDqEMwtTqL0RDf2u6le8e5PuD");
			add_location(clipPath, file$1, 48, 6, 1206);
			add_location(defs, file$1, 47, 4, 1193);
			attr_dev(ellipse, "vector-effect", "non-scaling-stroke");
			attr_dev(ellipse, "cx", "486.9999999999999");
			attr_dev(ellipse, "cy", "361.5");
			attr_dev(ellipse, "rx", "77.99999999999997");
			attr_dev(ellipse, "ry", "80.5");
			attr_dev(ellipse, "fill", "rgb(234,91,52)");
			add_location(ellipse, file$1, 54, 8, 1421);
			attr_dev(polygon, "points", "521.774,355.558,452,357,487.732,297.665");
			attr_dev(polygon, "fill", "rgb(235,235,235)");
			add_location(polygon, file$1, 56, 10, 1578);
			attr_dev(rect1, "x", "472");
			attr_dev(rect1, "y", "351");
			attr_dev(rect1, "width", "31");
			attr_dev(rect1, "height", "64");
			attr_dev(rect1, "transform", "matrix(1,0,0,1,0,0)");
			attr_dev(rect1, "fill", "rgb(235,235,235)");
			add_location(rect1, file$1, 57, 10, 1672);
			add_location(g0, file$1, 55, 8, 1564);
			add_location(g1, file$1, 53, 6, 1409);
			attr_dev(g2, "clip-path", "url(#_clipPath_pOOP9k0SDqEMwtTqL0RDf2u6le8e5PuD)");
			add_location(g2, file$1, 52, 4, 1338);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			set_style(svg, "isolation", "isolate");
			attr_dev(svg, "viewBox", "0 0 32 32");
			attr_dev(svg, "width", "32pt");
			attr_dev(svg, "height", "32pt");
			add_location(svg, file$1, 45, 2, 1027);
			attr_dev(a, "href", a_href_value = "" + (/*back*/ ctx[0] + "/#top"));
			attr_dev(a, "class", "fixed visible z-50 bottom-8 place-self-center\n  bg-orange-500 text-white active:bg-gray-700 text-lg\n  font-bold uppercase px-6 py-3 rounded shadow hover:shadow-lg\n  outline-none focus:outline-none mr-1 mb-1\n  transition duration-300 ease-in-out \n  hover:text-gray-800 hover:font-semibold transform hover:-translate-y-0 hover:scale-110");
			toggle_class(a, "hidden", /*hidden*/ ctx[1]);
			add_location(a, file$1, 37, 0, 639);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, svg);
			append_dev(svg, defs);
			append_dev(defs, clipPath);
			append_dev(clipPath, rect0);
			append_dev(svg, g2);
			append_dev(g2, g1);
			append_dev(g1, ellipse);
			append_dev(g1, g0);
			append_dev(g0, polygon);
			append_dev(g0, rect1);

			if (!mounted) {
				dispose = listen_dev(window, "scroll", /*handleOnScroll*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*back*/ 1 && a_href_value !== (a_href_value = "" + (/*back*/ ctx[0] + "/#top"))) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty & /*hidden*/ 2) {
				toggle_class(a, "hidden", /*hidden*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function goTop() {
	document.body.scrollIntoView();
}

function scrollContainer() {
	return document.documentElement || document.body;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("BackToTop", slots, []);
	let { showOnPx = 150 } = $$props;
	let { back } = $$props;
	let hidden = true;

	function handleOnScroll() {
		if (!scrollContainer()) {
			return;
		}

		if (scrollContainer().scrollTop > showOnPx) {
			$$invalidate(1, hidden = false);
		} else {
			$$invalidate(1, hidden = true);
		}
	}

	const writable_props = ["showOnPx", "back"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BackToTop> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("showOnPx" in $$props) $$invalidate(3, showOnPx = $$props.showOnPx);
		if ("back" in $$props) $$invalidate(0, back = $$props.back);
	};

	$$self.$capture_state = () => ({
		showOnPx,
		back,
		hidden,
		goTop,
		scrollContainer,
		handleOnScroll
	});

	$$self.$inject_state = $$props => {
		if ("showOnPx" in $$props) $$invalidate(3, showOnPx = $$props.showOnPx);
		if ("back" in $$props) $$invalidate(0, back = $$props.back);
		if ("hidden" in $$props) $$invalidate(1, hidden = $$props.hidden);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [back, hidden, handleOnScroll, showOnPx];
}

class BackToTop extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { showOnPx: 3, back: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BackToTop",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*back*/ ctx[0] === undefined && !("back" in props)) {
			console.warn("<BackToTop> was created without expected prop 'back'");
		}
	}

	get showOnPx() {
		throw new Error("<BackToTop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showOnPx(value) {
		throw new Error("<BackToTop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get back() {
		throw new Error("<BackToTop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set back(value) {
		throw new Error("<BackToTop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/LetterIndex.svelte generated by Svelte v3.35.0 */

const file = "src/components/LetterIndex.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (8:4) {#each letterIndex as indexLetter}
function create_each_block(ctx) {
	let a;
	let t_value = /*indexLetter*/ ctx[2].letter + "";
	let t;
	let a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, t_value);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "class", "mr-0.5 md:ml-2 lg:ml-3 text-base md:text-xl");
			attr_dev(a, "href", a_href_value = "" + (/*pageName*/ ctx[0] + "/" + /*indexLetter*/ ctx[2].name));
			add_location(a, file, 8, 6, 214);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*letterIndex*/ 2 && t_value !== (t_value = /*indexLetter*/ ctx[2].letter + "")) set_data_dev(t, t_value);

			if (dirty & /*pageName, letterIndex*/ 3 && a_href_value !== (a_href_value = "" + (/*pageName*/ ctx[0] + "/" + /*indexLetter*/ ctx[2].name))) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(8:4) {#each letterIndex as indexLetter}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let each_value = /*letterIndex*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "flex flex-wrap bg-gray-300 mb-2");
			add_location(div0, file, 6, 2, 123);
			attr_dev(div1, "class", "flex flex-col w-full place-items-center");
			add_location(div1, file, 5, 0, 67);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*pageName, letterIndex*/ 3) {
				each_value = /*letterIndex*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("LetterIndex", slots, []);
	let { pageName } = $$props;
	let { letterIndex } = $$props;
	const writable_props = ["pageName", "letterIndex"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LetterIndex> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("pageName" in $$props) $$invalidate(0, pageName = $$props.pageName);
		if ("letterIndex" in $$props) $$invalidate(1, letterIndex = $$props.letterIndex);
	};

	$$self.$capture_state = () => ({ pageName, letterIndex });

	$$self.$inject_state = $$props => {
		if ("pageName" in $$props) $$invalidate(0, pageName = $$props.pageName);
		if ("letterIndex" in $$props) $$invalidate(1, letterIndex = $$props.letterIndex);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [pageName, letterIndex];
}

class LetterIndex extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { pageName: 0, letterIndex: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LetterIndex",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*pageName*/ ctx[0] === undefined && !("pageName" in props)) {
			console.warn("<LetterIndex> was created without expected prop 'pageName'");
		}

		if (/*letterIndex*/ ctx[1] === undefined && !("letterIndex" in props)) {
			console.warn("<LetterIndex> was created without expected prop 'letterIndex'");
		}
	}

	get pageName() {
		throw new Error("<LetterIndex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pageName(value) {
		throw new Error("<LetterIndex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get letterIndex() {
		throw new Error("<LetterIndex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set letterIndex(value) {
		throw new Error("<LetterIndex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { BackToTop as B, LetterIndex as L, createNameIndex as c };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGV0dGVySW5kZXguNmY5MTk5ZmYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9jcmVhdGVOYW1lSW5kZXguanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9CYWNrVG9Ub3Auc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvTGV0dGVySW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENyZWF0ZSBhbiBpbmRleCB0aGF0IGFzc29jaWF0ZXMgbGV0dGVycyBvZiB0aGUgYWxwaGFiZXQgd2l0aCBcbi8vIHRoZSBmaXJzdCBwZXJzb24gaW4gdGhlIGxpc3Qgd2hvc2UgbGFzdCBuYW1lIHN0YXJ0cyB3aXRoIHRoYXQgbGV0dGVyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVOYW1lSW5kZXgocGVyc29ucykge1xuICBjb25zdCBhbHBoYWJldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWidcbiAgY29uc3QgbGV0dGVySW5kZXggPSBbXVxuXG4gIGZvcihsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxldHRlciA9IGFscGhhYmV0LmNoYXJBdChpKVxuICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSBwZXJzb25zLmZpbmQocGVyc29uID0+IHtcbiAgICAgIHJldHVybiBwZXJzb24ubGFzdE5hbWUuY2hhckF0KDApID09IGxldHRlciA/IHRydWUgOiBmYWxzZVxuICAgIH0pXG4gICAgaWYgKGZpcnN0TWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0dGVySW5kZXgucHVzaCh7IFxuICAgICAgICBsZXR0ZXI6IGxldHRlciwgXG4gICAgICAgIG5hbWU6IGAjJHsgZmlyc3RNYXRjaC5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnJykgfWBcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsZXR0ZXIgIT09ICdBJykge1xuICAgICAgICBsZXR0ZXJJbmRleC5wdXNoKHsgXG4gICAgICAgICAgbGV0dGVyOiBsZXR0ZXIsIFxuICAgICAgICAgIG5hbWU6IGxldHRlckluZGV4W2ktMV0ubmFtZSBcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGV0dGVySW5kZXhcbn0iLCI8c2NyaXB0PlxuICAvLyBCYXNlZCBvbjogaHR0cHM6Ly9zdmVsdGUuZGV2L3JlcGwvY2IxOTk3MzBlODNmNDFiZWI0ODRmZjUyMmM2NGJlYzE/dmVyc2lvbj0zLjM4LjJcblxuICBleHBvcnQgbGV0IHNob3dPblB4ID0gMTUwO1xuICBleHBvcnQgbGV0IGJhY2tcblxuICBsZXQgaGlkZGVuID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBnb1RvcCgpIHtcbiAgICBkb2N1bWVudC5ib2R5LnNjcm9sbEludG9WaWV3KCk7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT25TY3JvbGwoKSB7XG4gICAgaWYgKCFzY3JvbGxDb250YWluZXIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzY3JvbGxDb250YWluZXIoKS5zY3JvbGxUb3AgPiBzaG93T25QeCkge1xuICAgICAgaGlkZGVuID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGRlbiA9IHRydWU7XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBoaWRkZW4ge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG48L3N0eWxlPlxuXG48c3ZlbHRlOndpbmRvdyBvbjpzY3JvbGw9eyBoYW5kbGVPblNjcm9sbCB9IC8+XG5cbjxhIGhyZWY9XCJ7IGJhY2sgfS8jdG9wXCJcbiAgY2xhc3M9XCJmaXhlZCB2aXNpYmxlIHotNTAgYm90dG9tLTggcGxhY2Utc2VsZi1jZW50ZXJcbiAgYmctb3JhbmdlLTUwMCB0ZXh0LXdoaXRlIGFjdGl2ZTpiZy1ncmF5LTcwMCB0ZXh0LWxnXG4gIGZvbnQtYm9sZCB1cHBlcmNhc2UgcHgtNiBweS0zIHJvdW5kZWQgc2hhZG93IGhvdmVyOnNoYWRvdy1sZ1xuICBvdXRsaW5lLW5vbmUgZm9jdXM6b3V0bGluZS1ub25lIG1yLTEgbWItMVxuICB0cmFuc2l0aW9uIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCBcbiAgaG92ZXI6dGV4dC1ncmF5LTgwMCBob3Zlcjpmb250LXNlbWlib2xkIHRyYW5zZm9ybSBob3ZlcjotdHJhbnNsYXRlLXktMCBob3ZlcjpzY2FsZS0xMTBcIiBcbiAgY2xhc3M6aGlkZGVuPlxuICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiBcbiAgICBzdHlsZT1cImlzb2xhdGlvbjppc29sYXRlXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiIHdpZHRoPVwiMzJwdFwiIGhlaWdodD1cIjMycHRcIj5cbiAgICA8ZGVmcz5cbiAgICAgIDxjbGlwUGF0aCBpZD1cIl9jbGlwUGF0aF9wT09QOWswU0RxRU13dFRxTDBSRGYydTZsZThlNVB1RFwiPlxuICAgICAgICA8cmVjdCB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIi8+XG4gICAgICA8L2NsaXBQYXRoPlxuICAgIDwvZGVmcz5cbiAgICA8ZyBjbGlwLXBhdGg9XCJ1cmwoI19jbGlwUGF0aF9wT09QOWswU0RxRU13dFRxTDBSRGYydTZsZThlNVB1RClcIj5cbiAgICAgIDxnPlxuICAgICAgICA8ZWxsaXBzZSB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgY3g9XCI0ODYuOTk5OTk5OTk5OTk5OVwiIGN5PVwiMzYxLjVcIiByeD1cIjc3Ljk5OTk5OTk5OTk5OTk3XCIgcnk9XCI4MC41XCIgZmlsbD1cInJnYigyMzQsOTEsNTIpXCIvPlxuICAgICAgICA8Zz5cbiAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XCI1MjEuNzc0LDM1NS41NTgsNDUyLDM1Nyw0ODcuNzMyLDI5Ny42NjVcIiBmaWxsPVwicmdiKDIzNSwyMzUsMjM1KVwiLz5cbiAgICAgICAgICA8cmVjdCB4PVwiNDcyXCIgeT1cIjM1MVwiIHdpZHRoPVwiMzFcIiBoZWlnaHQ9XCI2NFwiIHRyYW5zZm9ybT1cIm1hdHJpeCgxLDAsMCwxLDAsMClcIiBmaWxsPVwicmdiKDIzNSwyMzUsMjM1KVwiLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9nPlxuICAgIDwvZz5cbiAgPC9zdmc+XG48L2E+IiwiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBwYWdlTmFtZVxuICBleHBvcnQgbGV0IGxldHRlckluZGV4XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImZsZXggZmxleC1jb2wgdy1mdWxsIHBsYWNlLWl0ZW1zLWNlbnRlclwiPlxuICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LXdyYXAgYmctZ3JheS0zMDAgbWItMlwiPlxuICAgIHsjZWFjaCBsZXR0ZXJJbmRleCBhcyBpbmRleExldHRlcn1cbiAgICAgIDxhIGNsYXNzPVwibXItMC41IG1kOm1sLTIgbGc6bWwtMyB0ZXh0LWJhc2UgbWQ6dGV4dC14bFwiIGhyZWY9XCJ7IHBhZ2VOYW1lIH0veyBpbmRleExldHRlci5uYW1lIH1cIj57IGluZGV4TGV0dGVyLmxldHRlciB9PC9hPlxuICAgIHsvZWFjaH1cbiAgPC9kaXY+XG48L2Rpdj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDZSxTQUFTLGVBQWUsQ0FBQyxPQUFPLEVBQUU7QUFDakQsRUFBRSxNQUFNLFFBQVEsR0FBRyw2QkFBNEI7QUFDL0MsRUFBRSxNQUFNLFdBQVcsR0FBRyxHQUFFO0FBQ3hCO0FBQ0EsRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFD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
